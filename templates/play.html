<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>נחש את ההרכב</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Heebo:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #f0f2f5; --text-color: #333; --primary-color: #3F51B5;
            --modal-bg: rgba(0, 0, 0, 0.7); --modal-content-bg: #fefefe; --key-bg: #e0e0e0;
            --feedback-correct: #28a745; --feedback-present: #ffc107; --feedback-absent: #6c757d;
        }
        body {
            font-family: 'Heebo', sans-serif; background-color: var(--bg-color); color: var(--text-color);
            margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center;
        }
        header { width: 100%; max-width: 600px; margin-bottom: 20px; text-align: center; }
        h1 { font-size: 2.5rem; color: #1a237e; }
        #game-info { font-size: 1.1rem; color: #555; }
        #team-text b { color: #333; }
        #player-list { width: 100%; max-width: 500px; display: flex; flex-direction: column; gap: 10px; }
        .player-row {
            display: flex; align-items: center; background-color: #fff; border-radius: 8px;
            padding: 15px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); transition: background-color 0.2s;
        }
        .player-row.unrevealed:hover { background-color: #e8eaf6; cursor: pointer; }
        .unrevealed-info { display: flex; align-items: center; gap: 15px; font-size: 1.2rem; width: 100%; }
        .player-number { font-weight: bold; color: var(--primary-color); min-width: 25px; text-align: center; }
        .revealed-info { display: flex; align-items: center; gap: 15px; }
        .revealed-info img { width: 50px; height: 50px; border-radius: 50%; object-fit: cover; }
        .revealed-info .details { text-align: right; }
        .revealed-info .name { font-size: 1.2rem; font-weight: bold; }
        #guess-modal {
            display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%;
            background-color: var(--modal-bg); align-items: center; justify-content: center;
        }
        #modal-content {
            background-color: var(--modal-content-bg); padding: 20px; border-radius: 10px;
            width: 90%; max-width: 500px; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            animation: modalOpen 0.3s; text-align: center;
        }
        @keyframes modalOpen { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        #modal-close { float: left; font-size: 28px; font-weight: bold; cursor: pointer; line-height: 1; }
        
        /* New styles for the 5-row grid */
        #wordle-grid { display: flex; flex-direction: column; gap: 5px; margin: 20px 0; }
        .wordle-row { display: flex; flex-direction: row-reverse; justify-content: center; gap: 4px; }

        .letter-box {
            width: 30px; height: 30px; border: 2px solid #ccc; display: flex; align-items: center;
            justify-content: center; font-size: 1.3rem; font-weight: bold; border-radius: 5px;
        }
        .letter-box.space { border: none; background-color: transparent; }
        .letter-box.correct { background-color: var(--feedback-correct); color: white; border-color: var(--feedback-correct); }
        .letter-box.present { background-color: var(--feedback-present); color: white; border-color: var(--feedback-present); }
        .letter-box.absent  { background-color: var(--feedback-absent); color: white; border-color: var(--feedback-absent); }
        #keyboard-feedback {
            color: #dc3545; /* Red color for the message */
            font-weight: bold;
            height: 20px; /* Reserve space to prevent layout shifting */
            margin-top: 10px;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        #keyboard-feedback.visible {
            opacity: 1;
        }
        #keyboard { display: grid; grid-template-columns: repeat(10, 1fr); gap: 5px; margin-top: 20px; }
        .key { padding: 10px 5px; font-size: 1.2rem; background-color: var(--key-bg); border: 1px solid #ccc; border-radius: 5px; cursor: pointer; }
        #key-submit { grid-column: span 3; background-color: #28a745; color: white; }
        #key-backspace { grid-column: span 2; background-color: #dc3545; color: white; }
        .key.correct {
            background-color: var(--feedback-correct);
            color: white;
        }
        .key.present {
            background-color: var(--feedback-present);
            color: white;
        }
        .key.absent {
            background-color: #a4a4a4; /* A darker gray to show it's used */
            color: #fefefe;
        }
    </style>
</head>
<body>
    <header>
        <h1>נחש את ההרכב</h1>
        <div id="game-info">
            <p id="competition-text">טוען משחק...</p>
            <p id="team-text"></p>
        </div>
    </header>
    <main id="player-list"></main>
    <div id="guess-modal">
        <div id="modal-content">
            <span id="modal-close">&times;</span>
            <h3 id="modal-title">נחש את השחקן</h3>
            <div id="wordle-grid"></div>
            <div id="keyboard-feedback"></div>
            <div id="keyboard"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const playerList = document.getElementById('player-list');
            const competitionText = document.getElementById('competition-text');
            const teamText = document.getElementById('team-text');
            const modal = document.getElementById('guess-modal');
            const modalClose = document.getElementById('modal-close');
            const modalTitle = document.getElementById('modal-title');
            const wordleGrid = document.getElementById('wordle-grid');
            const keyboardContainer = document.getElementById('keyboard');
            const keyboardFeedback = document.getElementById('keyboard-feedback');
            let feedbackTimeout; // To manage the timer for the feedback message
            let gameState = null;
            let activeSlotIndex = null;
            let currentGuess = "";
            let keyboardLetterStatus = {}; // Stores the status of each key ('correct', 'present', 'absent')
            const hebrewKeys = ['ק','ר','א','ט','ו','ן','ם','פ','ש','ד','ג','כ','ע','י','ח','ל','ך','ף','ז','ס','ב','ה','נ','מ','צ','ת','ץ'];

            // === NEW: State management for guesses ===
            let guessHistory = {}; // Stores guess history for each player
            let currentAttempt = 0; // Tracks the current guess row (0-4)
            const MAX_ATTEMPTS = 5;

            async function startGame() {
                try {
                    const response = await fetch('/start_game');
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    gameState = await response.json();
                    renderGame();
                } catch (error) {
                    competitionText.textContent = "שגיאה בטעינת המשחק. נסה לרענן.";
                    console.error("Error starting game:", error);
                }
            }

            function renderGame() {
                if (!gameState || !Array.isArray(gameState.lineup)) return;
                playerList.innerHTML = '';
                competitionText.textContent = gameState.competition;
                teamText.innerHTML = `<b>קבוצה לניחוש:</b> ${gameState.target_team_name}`;
                gameState.lineup.forEach(player => {
                    const playerRow = document.createElement('div');
                    playerRow.className = 'player-row';
                    if (player.is_revealed) {
                        playerRow.innerHTML = `<div class="revealed-info"><img src="${player.player_img_url || 'https://via.placeholder.com/60'}" alt="${player.revealed_name}"><div class="details"><div class="name">${player.revealed_name}</div></div></div>`;
                    } else {
                        playerRow.classList.add('unrevealed');
                        playerRow.dataset.index = player.index;
                        playerRow.innerHTML = `<div class="unrevealed-info"><div class="player-number">${player.jersey_number || player.index}</div><div class="player-position">${player.position}</div></div>`;
                    }
                    playerList.appendChild(playerRow);
                });
            }

            // Replace the existing openGuessModal function in your play.html with this one.

            function openGuessModal(slotIndex) {
                activeSlotIndex = slotIndex;
                const player = gameState.lineup.find(p => p.index === slotIndex);
                if (!player || typeof player.name !== 'string') return;

                // === THE FIX: Reset all state variables for the new player ===
                keyboardLetterStatus = {}; // 1. Clears the keyboard colors
                currentAttempt = 0;        // 2. Resets the guess to the first row
                currentGuess = "";         // 3. Clears any partially typed guess
                // =============================================================

                const playerName = player.name;
                modalTitle.textContent = `נחש את השחקן (עמדה: ${player.position})`;
                wordleGrid.innerHTML = '';

                const words = playerName.split(' ');
                const reversedWords = words.reverse();

                // Create the 5-row grid structure
                for (let i = 0; i < MAX_ATTEMPTS; i++) {
                    const row = document.createElement('div');
                    row.className = 'wordle-row';
                    
                    // Use a separate copy of reversedWords to avoid altering the original
                    [...reversedWords].forEach((word, wordIndex) => {
                        // Create the boxes for the current word
                        for (let j = 0; j < word.length; j++) {
                            const box = document.createElement('div');
                            box.className = 'letter-box';
                            row.appendChild(box);
                        }
                        // Add a space, except for the last word
                        if (wordIndex < reversedWords.length - 1) {
                            const space = document.createElement('div');
                            space.className = 'letter-box space';
                            row.appendChild(space);
                        }
                    });
                    wordleGrid.appendChild(row);
                }
                
                // Restore previous guesses for THIS player, if any
                if (guessHistory[slotIndex]) {
                    guessHistory[slotIndex].forEach((attempt, index) => {
                        updateKeyboardStatus(attempt.guess, attempt.feedback);
                        displayFeedback(attempt.feedback, index, attempt.guess);
                    });
                    currentAttempt = guessHistory[slotIndex].length;
                } else {
                    guessHistory[slotIndex] = [];
                }

                applyKeyboardColors(); // Apply the fresh (or restored) keyboard colors
                modal.style.display = 'flex';
            }
            
            async function submitGuess() {
                const player = gameState.lineup.find(p => p.index === activeSlotIndex);
                if (!player || currentAttempt >= MAX_ATTEMPTS || currentGuess.length !== player.name.replace(/ /g, '').length) return;

                try {
                    const response = await fetch('/guess', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ slot_index: activeSlotIndex, player: currentGuess })
                    });
                    if (!response.ok) throw new Error(`Guess submission failed`);
                    const result = await response.json();

                    if (result.feedback) {
                        // Store guess in history
                        const feedback = result.feedback.feedback;
                        guessHistory[activeSlotIndex].push({ guess: currentGuess, feedback: result.feedback.feedback });
                        // Display feedback on the current row
                        updateKeyboardStatus(currentGuess, feedback);
                        applyKeyboardColors();
                        displayFeedback(result.feedback.feedback, currentAttempt, currentGuess);
                        // Move to the next attempt
                        currentAttempt++;
                        currentGuess = "";
                        if (currentAttempt >= MAX_ATTEMPTS) {
                            alert('אין לך ניחושים נוספים!');
                        }
                    } else {
                        // Correct guess
                        gameState = result;
                        renderGame();
                        closeModal();
                        if (result.is_finished) setTimeout(() => alert(result.message), 300);
                    }
                } catch (error) {
                    console.error("Error submitting guess:", error);
                    alert("שגיאה בשליחת הניחוש. נסה שוב.");
                }
            }

            function displayFeedback(feedbackArray, attemptIndex, guess) {
                const row = wordleGrid.children[attemptIndex];
                if (!row) return;

                const boxes = Array.from(row.querySelectorAll('.letter-box:not(.space)'));
                const guessChars = guess.split(''); // The characters in their natural order

                // FIX: Apply feedback from right-to-left by reversing the box array.
                boxes.reverse().forEach((box, i) => {
                    if (i < guessChars.length) {
                        const feedback = feedbackArray[i];
                        box.textContent = guessChars[i];
                        
                        box.classList.remove('correct', 'present', 'absent');
                        if (feedback === 2) box.classList.add('correct');
                        else if (feedback === 1) box.classList.add('present');
                        else box.classList.add('absent');
                    }
                });
            }
            
            function updateWordleGrid() {
                if (currentAttempt >= MAX_ATTEMPTS) return;
                const row = wordleGrid.children[currentAttempt];
                const boxes = Array.from(row.querySelectorAll('.letter-box:not(.space)'));
                const guessChars = currentGuess.split(''); // The characters in their natural order

                // Clear all boxes first
                boxes.forEach(box => box.textContent = '');

                // FIX: Fill the boxes from right-to-left.
                // We reverse the array of HTML boxes, not the text itself.
                boxes.reverse().forEach((box, i) => {
                    if (i < guessChars.length) {
                        box.textContent = guessChars[i];
                    }
                });
            }

            function closeModal() {
                modal.style.display = 'none'; activeSlotIndex = null; currentGuess = "";
            }

            function createKeyboard() {
                keyboardContainer.innerHTML = '';
                hebrewKeys.forEach(key => {
                    const keyEl = document.createElement('button');
                    keyEl.className = 'key';
                    keyEl.textContent = key;
                    keyEl.addEventListener('click', () => {
                        const player = gameState.lineup.find(p => p.index === activeSlotIndex);
                        if (!player) return;
                        const maxLen = player.name.replace(/ /g, '').length;
                        if (currentGuess.length < maxLen) {
                            currentGuess += key;
                            updateWordleGrid();
                        }
                    });
                    keyboardContainer.appendChild(keyEl);
                });
                const backspaceKey = document.createElement('button');
                backspaceKey.id = 'key-backspace'; backspaceKey.className = 'key';
                backspaceKey.textContent = 'מחק';
                backspaceKey.addEventListener('click', () => {
                    currentGuess = currentGuess.slice(0, -1);
                    updateWordleGrid();
                });
                const submitKey = document.createElement('button');
                submitKey.id = 'key-submit'; submitKey.className = 'key';
                submitKey.textContent = 'נחש';
                submitKey.addEventListener('click', submitGuess);
                keyboardContainer.appendChild(backspaceKey);
                keyboardContainer.appendChild(submitKey);
            }
            // === ADD THIS ENTIRE NEW FUNCTION ===
// Applies colors to the on-screen keyboard based on the keyboardLetterStatus object
            function applyKeyboardColors() {
                const keys = keyboardContainer.querySelectorAll('.key');
                keys.forEach(keyEl => {
                    const letter = keyEl.textContent;
                    // Remove old statuses
                    keyEl.classList.remove('correct', 'present', 'absent');
                    // Add new status if it exists
                    if (keyboardLetterStatus[letter]) {
                        keyEl.classList.add(keyboardLetterStatus[letter]);
                    }
                });
            }

            // === ADD THIS ENTIRE NEW FUNCTION ===
            // Updates the keyboardLetterStatus object after a guess
            function updateKeyboardStatus(guess, feedback) {
                const guessChars = guess.split('');
                
                guessChars.forEach((char, index) => {
                    const currentStatus = keyboardLetterStatus[char];
                    const feedbackStatus = feedback[index];
                    
                    // Determine the new status based on the feedback number
                    let newStatus;
                    if (feedbackStatus === 2) newStatus = 'correct';
                    else if (feedbackStatus === 1) newStatus = 'present';
                    else newStatus = 'absent';
                    
                    // Only upgrade the status (Green > Yellow > Gray)
                    if (newStatus === 'correct') {
                        keyboardLetterStatus[char] = 'correct';
                    } else if (newStatus === 'present' && currentStatus !== 'correct') {
                        keyboardLetterStatus[char] = 'present';
                    } else if (newStatus === 'absent' && !currentStatus) {
                        keyboardLetterStatus[char] = 'absent';
                    }
                });
            }

            function showLanguageFeedback() {
                clearTimeout(feedbackTimeout); // Reset timer if already active
                keyboardFeedback.textContent = "יש להקליד בעברית";
                keyboardFeedback.classList.add('visible');
                feedbackTimeout = setTimeout(() => {
                    keyboardFeedback.classList.remove('visible');
                }, 2000); // Hide message after 2 seconds
            }
            
            playerList.addEventListener('click', (event) => {
                const row = event.target.closest('.player-row.unrevealed');
                if (row) {
                    const playerIndex = parseInt(row.dataset.index, 10);
                    if (playerIndex) openGuessModal(playerIndex);
                }
            });

            // === REPLACE the old 'keydown' listener with this one ===
            window.addEventListener('keydown', (event) => {
                // Do nothing if the modal isn't open or if it's the Escape key
                if (modal.style.display !== 'flex' || event.key === 'Escape') {
                    return;
                }

                const key = event.key;
                const hebrewAlphabet = 'אבגדהוזחטיכךלמםנןסעפףצץקרשת';
                const englishAlphabet = 'abcdefghijklmnopqrstuvwxyz';

                if (key === 'Enter') {
                    event.preventDefault();
                    submitGuess();
                } else if (key === 'Backspace') {
                    currentGuess = currentGuess.slice(0, -1);
                    updateWordleGrid();
                } else if (hebrewAlphabet.includes(key)) {
                    event.preventDefault();
                    const player = gameState.lineup.find(p => p.index === activeSlotIndex);
                    if (!player) return;
                    const maxLen = player.name.replace(/ /g, '').length;
                    if (currentGuess.length < maxLen) {
                        currentGuess += key;
                        updateWordleGrid();
                    }
                } else if (englishAlphabet.includes(key.toLowerCase())) {
                    // If an English letter is pressed, show the feedback
                    event.preventDefault();
                    showLanguageFeedback();
                }
            });
            // (The existing modalClose.addEventListener line should come after this)

            modalClose.addEventListener('click', closeModal);
            window.addEventListener('keydown', (e) => { if (e.key === "Escape") closeModal(); });

            createKeyboard();
            startGame();
        });
    </script>
</body>
</html>