<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>砖 转 专</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Heebo:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <style>
        :root {
            --bg-color: #f0f2f5; --text-color: #333; --primary-color: #3F51B5;
            --modal-bg: rgba(0, 0, 0, 0.7); --modal-content-bg: #fefefe; --key-bg: #e0e0e0;
            --feedback-correct: #28a745; --feedback-present: #ffc107; --feedback-absent: #6c757d;
            --error-color: #dc3545; --pitch-bg: #4CAF50; --pitch-line: #FFF;
        }
        body {
            /* === UPDATED STYLES === */
            font-family: 'Poppins', 'Heebo', sans-serif; /* Poppins first, Heebo as fallback */
            /* Subtle gradient background */
            background: linear-gradient(135deg, #e0eafc 0%, #cfdef3 100%); 
            color: #333; /* Keep text color */
            margin: 0; 
            padding: 20px; 
            display: flex; 
            flex-direction: column; 
            align-items: center;
            min-height: 100vh; /* Ensure gradient covers full height */
            text-align: center;
             /* Smooth font rendering */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Optional: Adjust header H1 for the new font */
        h1 { 
            font-size: 2.8rem; /* Slightly larger */
            color: #1a237e; 
            font-weight: 700; /* Bolder */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1); /* Subtle shadow */
        }

        /* Optional: Add a subtle border-radius to the pitch */
        #pitch {
            /* ... existing pitch styles ... */
            border-radius: 15px; /* Slightly more rounded */
        }

        /* Ensure modal looks good on new background */
         #modal-content {
             background-color: #ffffff; /* Explicit white background */
             /* ... other modal styles ... */
         }

        /* Ensure player list rows look good (if you switch back) */
         .player-row {
             background-color: #ffffff; /* Explicit white background */
              /* ... other player row styles ... */
         }
        header { width: 100%; max-width: 600px; margin-bottom: 20px; text-align: center; }
        h1 { font-size: 2.5rem; color: #1a237e; }
        #game-info { font-size: 1.1rem; color: #555; }
        #team-text b { color: #333; }

        /* === UPDATED: Pitch and Player Shirt Styles === */
        #pitch-container {
            width: 100%;
            display: flex;
            justify-content: center;
        }
        #pitch {
            width: 95vw;
            max-width: 500px;
            aspect-ratio: 7 / 10;
            background-color: var(--pitch-bg);
            border: 3px solid var(--pitch-line);
            border-radius: 10px;
            position: relative;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        #pitch::before { /* Center line */
            content: ''; position: absolute; z-index: 1; width: 100%; height: 50%;
            border-bottom: 3px solid var(--pitch-line); box-sizing: border-box; top: 0; left: 0;
        }
        #pitch::after { /* Center circle */
            content: ''; position: absolute; z-index: 1; width: 25%; aspect-ratio: 1 / 1;
            border: 3px solid var(--pitch-line); border-radius: 50%; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
        }
        .player-slot {
            position: absolute;
            transform: translate(-50%, -50%);
            cursor: pointer;
            transition: transform 0.2s ease;
            z-index: 2; /* Ensures players are on top of pitch markings */
        }
        .player-slot:hover { transform: translate(-50%, -50%) scale(1.1); }
        
        /* === UPDATED: Player Shirt Styling === */
        .player-shirt {
            font-size: 55px; /* Controls the size of the shirt icon */
            line-height: 1;  /* Aligns the icon nicely */
            position: relative; /* Needed to position the jersey number on top */
            color: var(--primary-color); /* Fallback color for the shirt */
        }

        /* New style for the jersey number, to place it on top of the shirt icon */
        .jersey-number {
            position: absolute;
            top: 55%; /* Vertically center */
            left: 50%; /* Horizontally center */
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            font-weight: bold;
            color: #FFFFFF; /* Default text color */
            text-shadow: 0 0 3px rgba(0,0,0,0.5); /* Adds a subtle shadow for readability */
        }
        /* Neckline for the shirt */
        
        .player-image {
            width: 60px; height: 60px; border-radius: 50%; border: 3px solid #fff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4); object-fit: cover; background-color: #ccc;
        }
        /* Add this rule to your CSS inside the <style> tag */
        .separator {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--text-color);
            margin: 0 2px; /* Adds a little space around the separator */
        }
        .match-details {
            display: flex;
            justify-content: space-around;
            align-items: center;
            background-color: #fff;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin-top: 15px;
        }
        .team-info {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.1rem;
            font-weight: bold;
        }
        .team-info img {
            width: 40px;
            height: 40px;
            object-fit: contain; /* Use contain to prevent distortion */
        }
        .score {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary-color);
            text-align: center; 
            /* You might also want to ensure it has enough space */
            flex-grow: 1; /* Allows it to take up available space between team names */
        }
        /* Style the target team name */
        .team-info.target-team span {
            color: var(--primary-color); /* Highlight the target team */
            /* text-decoration: underline; */
        }
        .stat-icons {
            position: absolute;
            top: -5px; /* Adjust position as needed */
            right: -5px; /* Adjust position as needed */
            display: flex;
            gap: 3px;
            z-index: 4; /* Ensure icons are above the shirt/number */
        }

        .card-icon {
            width: 10px;
            height: 14px;
            border: 1px solid #555;
            border-radius: 2px;
        }

        .yellow-card {
            background-color: #FFC107; /* Standard yellow card color */
        }

        .red-card {
            background-color: #DC3545; /* Standard red card color */
        }

        .goal-icon-container {
            display: flex;
            align-items: center;
            background-color: rgba(255, 255, 255, 0.7); /* Optional semi-transparent background */
            border-radius: 5px;
            padding: 1px 3px;
            font-size: 0.7rem;
            color: #000;
        }

        .goal-icon-container i { /* Style for Font Awesome football icon */
            font-size: 0.8rem;
            margin-left: 2px; /* Space between icon and number */
        }

        .goal-count {
            font-weight: bold;
        }
        
        /* Modal and keyboard styles remain the same as your working version */
        #guess-modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: var(--modal-bg); align-items: center; justify-content: center; }
        #modal-content { background-color: var(--modal-content-bg); padding: 20px; border-radius: 10px; width: 90%; max-width: 500px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); animation: modalOpen 0.3s; text-align: center; }
        @keyframes modalOpen { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        #modal-close { float: left; font-size: 28px; font-weight: bold; cursor: pointer; line-height: 1; }
        #wordle-grid { display: flex; flex-direction: column; gap: 5px; margin: 20px 0; }
        .wordle-row { display: flex; flex-direction: row-reverse; justify-content: center; gap: 4px; }
        .letter-box { width: 30px; height: 30px; border: 2px solid #ccc; display: flex; align-items: center; justify-content: center; font-size: 1.3rem; font-weight: bold; border-radius: 5px; }
        .letter-box.space { border: none; background-color: transparent; }
        .letter-box.correct { background-color: var(--feedback-correct); color: white; border-color: var(--feedback-correct); }
        .letter-box.present { background-color: var(--feedback-present); color: white; border-color: var(--feedback-present); }
        .letter-box.absent { background-color: var(--feedback-absent); color: white; border-color: var(--feedback-absent); }
        #keyboard-feedback { color: var(--error-color); font-weight: bold; height: 20px; margin-top: 10px; opacity: 0; transition: opacity 0.3s ease-in-out; }
        #keyboard-feedback.visible { opacity: 1; }
        #keyboard { display: grid; grid-template-columns: repeat(10, 1fr); gap: 5px; margin-top: 5px; }
        .key { padding: 10px 5px; font-size: 1.2rem; background-color: var(--key-bg); border: 1px solid #ccc; border-radius: 5px; cursor: pointer; }
        .key.correct { background-color: var(--feedback-correct); color: white; }
        .key.present { background-color: var(--feedback-present); color: white; }
        .key.absent { background-color: #a4a4a4; color: #fefefe; }
        #key-submit { grid-column: span 3; background-color: #28a745; color: white; }
        #key-backspace { grid-column: span 2; background-color: var(--error-color); color: white; }
        
    </style>
</head>
<body>
    <header>
        <h1>砖 转 专</h1>
        <div id="game-info">
            <p id="competition-title">注 砖拽...</p>
            <div class="match-details">
                <div class="team-info home-team">
                    <img id="home-team-logo" src="https://via.placeholder.com/40" alt="Home Team Logo">
                    <span id="home-team-name">Home Team</span>
                </div>
                <div class="score">
                    <span id="home-score">-</span> : <span id="away-score">-</span>
                </div>
                <div class="team-info away-team">
                    <span id="away-team-name">Away Team</span>
                    <img id="away-team-logo" src="https://via.placeholder.com/40" alt="Away Team Logo">
                </div>
            </div>
            <p id="target-team-notice" style="font-weight: bold; margin-top: 10px;"></p>
        </div>
    </header>
    <main id="pitch-container">
        <div id="pitch"></div>
    </main>
    
    <div id="guess-modal">
        <div id="modal-content">
            <span id="modal-close">&times;</span>
            <h3 id="modal-title">砖 转 砖拽</h3>
            <div id="wordle-grid"></div>
            <div id="keyboard-feedback"></div>
            <div id="keyboard"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const pitch = document.getElementById('pitch');
            const competitionText = document.getElementById('competition-text');
            const teamText = document.getElementById('team-text');
            const modal = document.getElementById('guess-modal');
            const modalClose = document.getElementById('modal-close');
            const modalTitle = document.getElementById('modal-title');
            const wordleGrid = document.getElementById('wordle-grid');
            const keyboardContainer = document.getElementById('keyboard');
            const keyboardFeedback = document.getElementById('keyboard-feedback');

            let gameState = null;
            let activeSlotIndex = null;
            let currentGuess = "";
            let guessHistory = {};
            let currentAttempt = 0;
            let keyboardLetterStatus = {};
            let feedbackTimeout;
            const MAX_ATTEMPTS = 5;
            const hebrewKeys = ['拽','专','','','','','','驻','砖','','','','注','','','','','祝','','住','','','','','爪','转','抓'];

            // === UPDATED: Expanded Color Map ===
            const colorMap = {
                "green": "#008000",   // A standard, rich green
                "orange": "#FF8C00",  // A dark, vibrant orange
                "yellow": "#FFC107",  // The darker yellow you requested
                "white": "#FFFFFF",
                "black": "#000000",
                "blue": "#0000FF",
                "red": "#FF0000"
            };

            async function startGame() {
                try {
                    const response = await fetch('/start_game');
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    gameState = await response.json();
                    renderGame();
                } catch (error) {
                    competitionText.textContent = "砖 注转 砖拽. 住 专注.";
                    console.error("Error starting game:", error);
                }
            }
            
            // Replace the renderGame function in your <script> tag
            function renderGame() {
                if (!gameState || !Array.isArray(gameState.lineup)) return;

                    pitch.innerHTML = ''; // Clear the pitch

    // --- NEW HEADER POPULATION LOGIC ---
                document.getElementById('competition-title').textContent = gameState.competition_title;

                const homeTeamLogo = document.getElementById('home-team-logo');
                const homeTeamName = document.getElementById('home-team-name');
                const awayTeamLogo = document.getElementById('away-team-logo');
                const awayTeamName = document.getElementById('away-team-name');
                const homeScore = document.getElementById('home-score');
                const awayScore = document.getElementById('away-score');
                const targetTeamNotice = document.getElementById('target-team-notice');

                homeTeamLogo.src = gameState.home_team_img_url || 'https://via.placeholder.com/40';
                homeTeamName.textContent = gameState.home_team_name;
                homeScore.textContent = gameState.score_home ?? '-'; // Use ?? for nullish coalescing

                awayTeamLogo.src = gameState.away_team_img_url || 'https://via.placeholder.com/40';
                awayTeamName.textContent = gameState.away_team_name;
                awayScore.textContent = gameState.score_away ?? '-';

                // Highlight the target team
                homeTeamName.parentElement.classList.remove('target-team');
                awayTeamName.parentElement.classList.remove('target-team');
                if (gameState.target_team_name === gameState.home_team_name) {
                    homeTeamName.parentElement.classList.add('target-team');
                } else {
                    awayTeamName.parentElement.classList.add('target-team');
                }
                targetTeamNotice.innerHTML = `<b>拽爪 砖:</b> ${gameState.target_team_name}`;
                // --- END HEADER LOGIC ---

                const lineupWithPositions = getLineupWithPositions(gameState.lineup, gameState.team_formation);

                lineupWithPositions.forEach(({ player, position }, index) => {
                    try {
                        console.log(` -> Processing player index ${player?.index}`); // Log start for this player

                        const playerEl = createPlayerElement(player, position);

                        if (playerEl) {
                            console.log(`    --> Element created for player index ${player?.index}`); // Log creation success
                            pitch.appendChild(playerEl);
                            console.log(`      --> Element appended for player index ${player?.index}`); // Log append success
                        } else {
                            console.error(`      --> createPlayerElement returned null for player index ${player?.index}`);
                        }
                    } catch (loopError) {
                        console.error(` Error processing/appending player index ${player?.index}:`, loopError, "Player:", player, "Position:", position);
                        // Continue to the next player
                    }
                });
            }

            // === UPDATED: createPlayerElement for shirt shape and multiple stripes ===
            function createPlayerElement(player, position) {
                const slot = document.createElement('div');
                slot.className = 'player-slot';

                const statIconsContainer = document.createElement('div');
                statIconsContainer.className = 'stat-icons';
                let goalCount = 0;

                // Check if player_stats exists and is an array
                if (player && player.player_stats && Array.isArray(player.player_stats)) {
                    player.player_stats.forEach(stat => {
                        if (stat === "yellow card") {
                            const card = document.createElement('div');
                            card.className = 'card-icon yellow-card';
                            statIconsContainer.appendChild(card);
                        } else if (stat === "red card") {
                            const card = document.createElement('div');
                            card.className = 'card-icon red-card';
                            statIconsContainer.appendChild(card);
                        } else if (stat.includes("goals")) {
                            // Extract number of goals (e.g., from "2 goals")
                            const match = stat.match(/(\d+)/);
                            if (match) {
                                goalCount = parseInt(match[1], 10);
                            }
                        }
                    });
                }

                // Add goal icon if goals were scored
                if (goalCount > 0) {
                    const goalContainer = document.createElement('div');
                    goalContainer.className = 'goal-icon-container';
                    const ballIcon = document.createElement('i');
                    ballIcon.className = 'fa-solid fa-futbol'; // Font Awesome football icon
                    goalContainer.appendChild(ballIcon);
                    if (goalCount > 1) {
                        const countSpan = document.createElement('span');
                        countSpan.className = 'goal-count';
                        countSpan.textContent = `x${goalCount}`;
                        goalContainer.appendChild(countSpan);
                    }
                    statIconsContainer.appendChild(goalContainer);
                }

                if (player.is_revealed) {
                    const img = document.createElement('img');
                    img.src = player.player_img_url || 'https://via.placeholder.com/60';
                    img.alt = player.revealed_name;
                    img.className = 'player-image';
                    slot.appendChild(img);
                    slot.appendChild(statIconsContainer);
                } else {
                    const shirtIcon = document.createElement('i');
                    shirtIcon.className = 'fa-solid fa-shirt player-shirt';
                    const number = document.createElement('span');
                    number.className = 'jersey-number';
                    number.textContent = player.jersey_number || player.index;
                    
                    if (gameState.shirt_colors) {
                        const colorNames = gameState.shirt_colors.split(',').map(name => name.trim().toLowerCase());
                        const hexColors = colorNames.map(name => colorMap[name] || '#3F51B5'); // Default blue

                        if (hexColors.length === 2) {
                            const c1 = hexColors[0];
                            const c2 = hexColors[1];
                        
                            shirtIcon.style.backgroundImage = `linear-gradient(to right, ${c1} 25%, ${c2} 25%, ${c2} 50%, ${c1} 50%, ${c1} 75%, ${c2} 75%)`;
                            shirtIcon.style.webkitBackgroundClip = 'text'; // For Safari/Chrome
                            shirtIcon.style.backgroundClip = 'text';
                            shirtIcon.style.color = 'transparent'; // Make the icon itself transparent to show the gradient
                        } else {
                            // Single color
                            shirtIcon.style.color = hexColors[0];
                        }
                    

                        // Text color logic
                        let textColor = gameState.text_color || '#FFFFFF'; // Default to white
                        if (colorNames.includes('white')) {
                            textColor = '#000000'; // Force black text on white shirts
                        }
                        number.style.color = textColor;
                    }
                    
                    slot.appendChild(shirtIcon);
                    slot.appendChild(number);
                    slot.appendChild(statIconsContainer);
                    slot.addEventListener('click', () => {
                        openGuessModal(player.index);
                    });
                }
                
                slot.style.top = `${position.y}%`;
                slot.style.left = `${position.x}%`;
                return slot;
            }

            // In play.html, replace the entire getLineupWithPositions function

            // In play.html, replace the entire getLineupWithPositions function

            // Replace your existing getLineupWithPositions function with this one

            // In play.html, replace the entire getLineupWithPositions function

            function getLineupWithPositions(lineup, formationStr) {
                // --- Step 1: Templates (No change here) ---
                const formationTemplates = { /* ... keep all your formation templates ... */
                    "4-4-2": [ { x: 50, y: 90 }, { x: 15, y: 75 }, { x: 35, y: 78 }, { x: 65, y: 78 }, { x: 85, y: 75 }, { x: 15, y: 50 }, { x: 35, y: 50 }, { x: 65, y: 50 }, { x: 85, y: 50 }, { x: 35, y: 20 }, { x: 65, y: 20 } ],
                    "4-3-3": [ { x: 50, y: 90 }, { x: 15, y: 75 }, { x: 35, y: 78 }, { x: 65, y: 78 }, { x: 85, y: 75 }, { x: 25, y: 50 }, { x: 50, y: 55 }, { x: 75, y: 50 }, { x: 20, y: 20 }, { x: 50, y: 18 }, { x: 80, y: 20 } ],
                    "3-5-2": [ { x: 50, y: 90 }, { x: 25, y: 78 }, { x: 50, y: 80 }, { x: 75, y: 78 }, { x: 10, y: 50 }, { x: 30, y: 55 }, { x: 50, y: 60 }, { x: 70, y: 55 }, { x: 90, y: 50 }, { x: 35, y: 20 }, { x: 65, y: 20 } ],
                    "5-3-2": [ { x: 50, y: 90 }, { x: 10, y: 70 }, { x: 30, y: 78 }, { x: 50, y: 80 }, { x: 70, y: 78 }, { x: 90, y: 70 }, { x: 25, y: 50 }, { x: 50, y: 55 }, { x: 75, y: 50 }, { x: 35, y: 20 }, { x: 65, y: 20 } ],
                    "4-5-1": [ { x: 50, y: 90 }, { x: 15, y: 75 }, { x: 35, y: 78 }, { x: 65, y: 78 }, { x: 85, y: 75 }, { x: 10, y: 50 }, { x: 30, y: 55 }, { x: 50, y: 60 }, { x: 70, y: 55 }, { x: 90, y: 50 }, { x: 50, y: 20 } ],
                    "4-2-4": [ { x: 50, y: 90 }, { x: 15, y: 75 }, { x: 35, y: 78 }, { x: 65, y: 78 }, { x: 85, y: 75 }, { x: 30, y: 55 }, { x: 70, y: 55 }, { x: 10, y: 25 }, { x: 35, y: 20 }, { x: 65, y: 20 }, { x: 90, y: 25 } ],
                    "5-1-4": [ { x: 50, y: 90 }, { x: 10, y: 70 }, { x: 30, y: 78 }, { x: 50, y: 80 }, { x: 70, y: 78 }, { x: 90, y: 70 }, { x: 50, y: 60 }, { x: 10, y: 25 }, { x: 35, y: 20 }, { x: 65, y: 20 }, { x: 90, y: 25 } ],
                    "5-2-3": [ { x: 50, y: 90 }, { x: 10, y: 70 }, { x: 30, y: 78 }, { x: 50, y: 80 }, { x: 70, y: 78 }, { x: 90, y: 70 }, { x: 30, y: 55 }, { x: 70, y: 55 }, { x: 20, y: 20 }, { x: 50, y: 18 }, { x: 80, y: 20 } ],
                    "3-3-4": [ { x: 50, y: 90 }, { x: 25, y: 78 }, { x: 50, y: 80 }, { x: 75, y: 78 }, { x: 25, y: 50 }, { x: 50, y: 55 }, { x: 75, y: 50 }, { x: 10, y: 25 }, { x: 35, y: 20 }, { x: 65, y: 20 }, { x: 90, y: 25 } ],
                    "3-4-3": [ { x: 50, y: 90 }, { x: 25, y: 78 }, { x: 50, y: 80 }, { x: 75, y: 78 }, { x: 15, y: 50 }, { x: 35, y: 55 }, { x: 65, y: 55 }, { x: 85, y: 50 }, { x: 20, y: 20 }, { x: 50, y: 18 }, { x: 80, y: 20 } ],
                    "5-4-1": [ { x: 50, y: 90 }, { x: 10, y: 70 }, { x: 30, y: 78 }, { x: 50, y: 80 }, { x: 70, y: 78 }, { x: 90, y: 70 }, { x: 15, y: 50 }, { x: 35, y: 50 }, { x: 65, y: 50 }, { x: 85, y: 50 }, { x: 50, y: 20 } ],
                    "default": [ { x: 50, y: 90 }, { x: 15, y: 75 }, { x: 35, y: 78 }, { x: 65, y: 78 }, { x: 85, y: 75 }, { x: 15, y: 50 }, { x: 35, y: 50 }, { x: 65, y: 50 }, { x: 85, y: 50 }, { x: 35, y: 20 }, { x: 65, y: 20 } ]
                };

                // --- Step 2: Update Position Mappings ---
                const positionMap = [
                    { key: 'GK', names: ['GOAL'], line: 0 },
                    { key: 'DF', names: ['BACK', 'DEFEN'], line: 1 },
                    { key: 'MF', names: ['MIDFIELD'], line: 2 }, // Removed 'WINGER'
                    // Moved 'WINGER' here to the Attack category
                    { key: 'FW', names: ['FORWARD', 'STRIKER', 'ATTACK', 'WINGER'], line: 3 }
                ];

                // --- Step 3: Update Sorting Order Map ---
                const gamePosOrder = {
                    // GK
                    "Goalkeeper": 1,
                    // Defence (Sorted Right to Left)
                    "Left-Back": 10,
                    "Centre-Back": 11,
                    "Defender": 11,
                    "Right-Back": 12,
                    // Midfield (Sorted Right to Left)
                    "Left Midfield": 20,
                    "Defensive Midfield": 21, // DM slightly behind CM
                    "Central Midfield": 22,
                    "Midfielder": 22,
                    "Attacking Midfield": 23, // AM slightly ahead of CM
                    "Right Midfield": 24,
                    // Attack (Sorted Right Winger -> Strikers -> Left Winger)
                    "Left Winger": 30,
                    "Second Striker": 31,
                    "Centre-Forward": 32,
                    "Striker": 32,
                    "Right Winger": 33,
                    // Fallback
                    "Unknown": 99
                };

                // --- Step 4: Sort the lineup using the updated game_pos order ---
                const sortedLineup = [...lineup].sort((a, b) => {
                    const posA_str = a.game_pos || a.position || 'Unknown';
                    const posB_str = b.game_pos || b.position || 'Unknown';
                    const orderA = gamePosOrder[posA_str] || 99;
                    const orderB = gamePosOrder[posB_str] || 99;
                    if (orderA !== orderB) {
                        return orderA - orderB;
                    }
                    return a.index - b.index; // Stable sort using original index
                });

                // --- Step 5: Map sorted players to the selected template ---
                const validFormationStr = formationTemplates[formationStr] ? formationStr : "default";
                const template = formationTemplates[validFormationStr];

                const result = [];
                for (let i = 0; i < sortedLineup.length; i++) {
                    if (i >= template.length) break;
                    result.push({
                        player: sortedLineup[i],
                        position: template[i]
                    });
                }

                // --- Step 6: Re-order results to match the original lineup index ---
                const finalPositions = lineup.map(originalPlayer => {
                    const found = result.find(item => item.player.index === originalPlayer.index);
                    return found || { player: originalPlayer, position: { x: 50, y: 50 + (originalPlayer.index || 0) * 2 } };
                });

                return finalPositions.slice(0, 11);
            }

            function openGuessModal(slotIndex) {
                activeSlotIndex = slotIndex;
                const player = gameState.lineup.find(p => p.index === slotIndex);
                if (!player || typeof player.name !== 'string') return;
                
                keyboardLetterStatus = {};
                currentAttempt = 0;
                currentGuess = "";

                const playerName = player.name;
                modalTitle.textContent = `砖 转 砖拽 (注: ${player.position})`;
                wordleGrid.innerHTML = '';
                
                const nameParts = playerName.split(/([ '])/).filter(part => part.length > 0);

                for (let i = 0; i < MAX_ATTEMPTS; i++) {
                    const row = document.createElement('div');
                    row.className = 'wordle-row';

                    // Rebuild the structure for each row
                    nameParts.slice().reverse().forEach(part => { // Reverse for RTL display
                        if (part === ' ' || part === "'") {
                            // If the part is a separator, create a separator element
                            const separator = document.createElement('div');
                            separator.className = 'separator';
                            separator.textContent = part;
                            row.appendChild(separator);
                        } else {
                            // If it's a word, create letter boxes for it
                            for (let j = 0; j < part.length; j++) {
                                const box = document.createElement('div');
                                box.className = 'letter-box';
                                row.appendChild(box);
                            }
                        }
                    });
                    wordleGrid.appendChild(row);
                }
                if (guessHistory[slotIndex]) {
                    guessHistory[slotIndex].forEach((attempt, index) => {
                        updateKeyboardStatus(attempt.guess, attempt.feedback);
                        displayFeedback(attempt.feedback, index, attempt.guess);
                    });
                    currentAttempt = guessHistory[slotIndex].length;
                } else {
                    guessHistory[slotIndex] = [];
                }
                
                applyKeyboardColors();
                modal.style.display = 'flex';
            }
            
            async function submitGuess() {
                const player = gameState.lineup.find(p => p.index === activeSlotIndex);
                if (!player || currentAttempt >= MAX_ATTEMPTS || currentGuess.length !== player.guess_length) return;
                try {
                    const response = await fetch('/guess', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ slot_index: activeSlotIndex, player: currentGuess }) });
                    if (!response.ok) throw new Error(`Guess submission failed`);
                    const result = await response.json();
                    if (result.feedback) {
                        const feedback = result.feedback.feedback;
                        guessHistory[activeSlotIndex].push({ guess: currentGuess, feedback: feedback });
                        updateKeyboardStatus(currentGuess, feedback);
                        applyKeyboardColors();
                        displayFeedback(feedback, currentAttempt, currentGuess);
                        currentAttempt++;
                        currentGuess = "";
                        if (currentAttempt >= MAX_ATTEMPTS) { alert('  砖 住驻!'); }
                    } else {
                        gameState = result;
                        renderGame();
                        closeModal();
                        if (result.is_finished) setTimeout(() => alert(result.message), 300);
                    }
                } catch (error) {
                    console.error("Error submitting guess:", error);
                    alert("砖 砖转 砖. 住 砖.");
                }
            }
            
            function updateWordleGrid() {
                if (currentAttempt >= MAX_ATTEMPTS) return;
                const row = wordleGrid.children[currentAttempt];
                const boxes = Array.from(row.querySelectorAll('.letter-box:not(.space)'));
                const guessChars = currentGuess.split('');
                boxes.forEach(box => box.textContent = '');
                boxes.reverse().forEach((box, i) => { if (i < guessChars.length) { box.textContent = guessChars[i]; } });
            }
            
            function displayFeedback(feedbackArray, attemptIndex, guess) {
                const row = wordleGrid.children[attemptIndex];
                if (!row) return;
                const boxes = Array.from(row.querySelectorAll('.letter-box'));
                const guessChars = guess.split('');
                boxes.reverse().forEach((box, i) => {
                    if (i < guessChars.length) {
                        const feedback = feedbackArray[i];
                        box.textContent = guessChars[i];
                        box.classList.remove('correct', 'present', 'absent');
                        if (feedback === 2) box.classList.add('correct');
                        else if (feedback === 1) box.classList.add('present');
                        else box.classList.add('absent');
                    }
                });
            }

            function updateKeyboardStatus(guess, feedback) {
                const guessChars = guess.split('');
                guessChars.forEach((char, index) => {
                    const currentStatus = keyboardLetterStatus[char];
                    let newStatus;
                    if (feedback[index] === 2) newStatus = 'correct';
                    else if (feedback[index] === 1) newStatus = 'present';
                    else newStatus = 'absent';
                    if (newStatus === 'correct' || (newStatus === 'present' && currentStatus !== 'correct') || (newStatus === 'absent' && !currentStatus)) {
                        keyboardLetterStatus[char] = newStatus;
                    }
                });
            }
            
            function applyKeyboardColors() {
                keyboardContainer.querySelectorAll('.key').forEach(keyEl => {
                    const letter = keyEl.textContent;
                    keyEl.classList.remove('correct', 'present', 'absent');
                    if (keyboardLetterStatus[letter]) {
                        keyEl.classList.add(keyboardLetterStatus[letter]);
                    }
                });
            }
            
            function showLanguageFeedback() {
                clearTimeout(feedbackTimeout);
                keyboardFeedback.textContent = "砖 拽 注专转";
                keyboardFeedback.classList.add('visible');
                feedbackTimeout = setTimeout(() => {
                    keyboardFeedback.classList.remove('visible');
                }, 2000);
            }
            
            function closeModal() { modal.style.display = 'none'; activeSlotIndex = null; }
            
            function createKeyboard() {
                keyboardContainer.innerHTML = '';
                hebrewKeys.forEach(key => {
                    const keyEl = document.createElement('button');
                    keyEl.className = 'key';
                    keyEl.textContent = key;
                    keyEl.addEventListener('click', () => {
                        const player = gameState.lineup.find(p => p.index === activeSlotIndex);
                        if (!player) return;
                        const maxLen = player.name.replace(/ /g, '').length;
                        if (currentGuess.length < maxLen) {
                            currentGuess += key;
                            updateWordleGrid();
                        }
                    });
                    keyboardContainer.appendChild(keyEl);
                });
                const backspaceKey = document.createElement('button');
                backspaceKey.id = 'key-backspace'; backspaceKey.className = 'key'; backspaceKey.textContent = '拽';
                backspaceKey.addEventListener('click', () => { currentGuess = currentGuess.slice(0, -1); updateWordleGrid(); });
                const submitKey = document.createElement('button');
                submitKey.id = 'key-submit'; submitKey.className = 'key'; submitKey.textContent = '砖';
                submitKey.addEventListener('click', submitGuess);
                keyboardContainer.appendChild(backspaceKey);
                keyboardContainer.appendChild(submitKey);
            }

            window.addEventListener('keydown', (event) => {
                if (modal.style.display !== 'flex' || event.key === 'Escape') return;
                const key = event.key;
                const hebrewAlphabet = '住注驻祝爪抓拽专砖转';
                const englishAlphabet = 'abcdefghijklmnopqrstuvwxyz';
                if (key === 'Enter') {
                    event.preventDefault(); submitGuess();
                } else if (key === 'Backspace') {
                    currentGuess = currentGuess.slice(0, -1); updateWordleGrid();
                } else if (hebrewAlphabet.includes(key)) {
                    event.preventDefault();
                    const player = gameState.lineup.find(p => p.index === activeSlotIndex);
                    if (!player) return;
                    const maxLen = player.name.replace(/ /g, '').length;
                    if (currentGuess.length < maxLen) { currentGuess += key; updateWordleGrid(); }
                } else if (englishAlphabet.includes(key.toLowerCase())) {
                    event.preventDefault(); showLanguageFeedback();
                }
            });

            modalClose.addEventListener('click', closeModal);
            window.addEventListener('keydown', (e) => { if (e.key === "Escape") closeModal(); });

            createKeyboard();
            startGame();
        });
    </script>
</body>
</html>